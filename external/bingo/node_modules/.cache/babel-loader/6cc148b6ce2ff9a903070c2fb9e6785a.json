{"ast":null,"code":"'use strict';\n\nvar legacy = require('character-entities-legacy');\n\nvar invalid = require('character-reference-invalid');\n\nvar decimal = require('is-decimal');\n\nvar hexadecimal = require('is-hexadecimal');\n\nvar alphanumerical = require('is-alphanumerical');\n\nvar decodeEntity = require('./decode-entity');\n\nmodule.exports = parseEntities;\nvar own = {}.hasOwnProperty;\nvar fromCharCode = String.fromCharCode;\nvar noop = Function.prototype;\n/* Default settings. */\n\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n};\n/* Reference types. */\n\nvar NAMED = 'named';\nvar HEXADECIMAL = 'hexadecimal';\nvar DECIMAL = 'decimal';\n/* Map of bases. */\n\nvar BASE = {};\nBASE[HEXADECIMAL] = 16;\nBASE[DECIMAL] = 10;\n/* Map of types to tests. Each type of character reference\n * accepts different characters. This test is used to\n * detect whether a reference has ended (as the semicolon\n * is not strictly needed). */\n\nvar TESTS = {};\nTESTS[NAMED] = alphanumerical;\nTESTS[DECIMAL] = decimal;\nTESTS[HEXADECIMAL] = hexadecimal;\n/* Warning messages. */\n\nvar NAMED_NOT_TERMINATED = 1;\nvar NUMERIC_NOT_TERMINATED = 2;\nvar NAMED_EMPTY = 3;\nvar NUMERIC_EMPTY = 4;\nvar NAMED_UNKNOWN = 5;\nvar NUMERIC_DISALLOWED = 6;\nvar NUMERIC_PROHIBITED = 7;\nvar MESSAGES = {};\nMESSAGES[NAMED_NOT_TERMINATED] = 'Named character references must be terminated by a semicolon';\nMESSAGES[NUMERIC_NOT_TERMINATED] = 'Numeric character references must be terminated by a semicolon';\nMESSAGES[NAMED_EMPTY] = 'Named character references cannot be empty';\nMESSAGES[NUMERIC_EMPTY] = 'Numeric character references cannot be empty';\nMESSAGES[NAMED_UNKNOWN] = 'Named character references must be known';\nMESSAGES[NUMERIC_DISALLOWED] = 'Numeric character references cannot be disallowed';\nMESSAGES[NUMERIC_PROHIBITED] = 'Numeric character references cannot be outside the permissible Unicode range';\n/* Wrap to ensure clean parameters are given to `parse`. */\n\nfunction parseEntities(value, options) {\n  var settings = {};\n  var option;\n  var key;\n\n  if (!options) {\n    options = {};\n  }\n\n  for (key in defaults) {\n    option = options[key];\n    settings[key] = option === null || option === undefined ? defaults[key] : option;\n  }\n\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || [];\n    settings.position = settings.position.start;\n  }\n\n  return parse(value, settings);\n}\n/* Parse entities. */\n\n\nfunction parse(value, settings) {\n  var additional = settings.additional;\n  var nonTerminated = settings.nonTerminated;\n  var handleText = settings.text;\n  var handleReference = settings.reference;\n  var handleWarning = settings.warning;\n  var textContext = settings.textContext;\n  var referenceContext = settings.referenceContext;\n  var warningContext = settings.warningContext;\n  var pos = settings.position;\n  var indent = settings.indent || [];\n  var length = value.length;\n  var index = 0;\n  var lines = -1;\n  var column = pos.column || 1;\n  var line = pos.line || 1;\n  var queue = '';\n  var result = [];\n  var entityCharacters;\n  var namedEntity;\n  var terminated;\n  var characters;\n  var character;\n  var reference;\n  var following;\n  var warning;\n  var reason;\n  var output;\n  var entity;\n  var begin;\n  var start;\n  var type;\n  var test;\n  var prev;\n  var next;\n  var diff;\n  var end;\n  /* Cache the current point. */\n\n  prev = now();\n  /* Wrap `handleWarning`. */\n\n  warning = handleWarning ? parseError : noop;\n  /* Ensure the algorithm walks over the first character\n   * and the end (inclusive). */\n\n  index--;\n  length++;\n\n  while (++index < length) {\n    /* If the previous character was a newline. */\n    if (character === '\\n') {\n      column = indent[lines] || 1;\n    }\n\n    character = at(index);\n    /* Handle anything other than an ampersand,\n     * including newlines and EOF. */\n\n    if (character !== '&') {\n      if (character === '\\n') {\n        line++;\n        lines++;\n        column = 0;\n      }\n\n      if (character) {\n        queue += character;\n        column++;\n      } else {\n        flush();\n      }\n    } else {\n      following = at(index + 1);\n      /* The behaviour depends on the identity of the next\n       * character. */\n\n      if (following === '\\t'\n      /* Tab */\n      || following === '\\n'\n      /* Newline */\n      || following === '\\f'\n      /* Form feed */\n      || following === ' '\n      /* Space */\n      || following === '<'\n      /* Less-than */\n      || following === '&'\n      /* Ampersand */\n      || following === '' || additional && following === additional) {\n        /* Not a character reference. No characters\n         * are consumed, and nothing is returned.\n         * This is not an error, either. */\n        queue += character;\n        column++;\n        continue;\n      }\n\n      start = index + 1;\n      begin = start;\n      end = start;\n      /* Numerical entity. */\n\n      if (following !== '#') {\n        type = NAMED;\n      } else {\n        end = ++begin;\n        /* The behaviour further depends on the\n         * character after the U+0023 NUMBER SIGN. */\n\n        following = at(end);\n\n        if (following === 'x' || following === 'X') {\n          /* ASCII hex digits. */\n          type = HEXADECIMAL;\n          end = ++begin;\n        } else {\n          /* ASCII digits. */\n          type = DECIMAL;\n        }\n      }\n\n      entityCharacters = '';\n      entity = '';\n      characters = '';\n      test = TESTS[type];\n      end--;\n\n      while (++end < length) {\n        following = at(end);\n\n        if (!test(following)) {\n          break;\n        }\n\n        characters += following;\n        /* Check if we can match a legacy named\n         * reference.  If so, we cache that as the\n         * last viable named reference.  This\n         * ensures we do not need to walk backwards\n         * later. */\n\n        if (type === NAMED && own.call(legacy, characters)) {\n          entityCharacters = characters;\n          entity = legacy[characters];\n        }\n      }\n\n      terminated = at(end) === ';';\n\n      if (terminated) {\n        end++;\n        namedEntity = type === NAMED ? decodeEntity(characters) : false;\n\n        if (namedEntity) {\n          entityCharacters = characters;\n          entity = namedEntity;\n        }\n      }\n\n      diff = 1 + end - start;\n\n      if (!terminated && !nonTerminated) {\n        /* Empty. */\n      } else if (!characters) {\n        /* An empty (possible) entity is valid, unless\n         * its numeric (thus an ampersand followed by\n         * an octothorp). */\n        if (type !== NAMED) {\n          warning(NUMERIC_EMPTY, diff);\n        }\n      } else if (type === NAMED) {\n        /* An ampersand followed by anything\n         * unknown, and not terminated, is invalid. */\n        if (terminated && !entity) {\n          warning(NAMED_UNKNOWN, 1);\n        } else {\n          /* If theres something after an entity\n           * name which is not known, cap the\n           * reference. */\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          }\n          /* If the reference is not terminated,\n           * warn. */\n\n\n          if (!terminated) {\n            reason = entityCharacters ? NAMED_NOT_TERMINATED : NAMED_EMPTY;\n\n            if (!settings.attribute) {\n              warning(reason, diff);\n            } else {\n              following = at(end);\n\n              if (following === '=') {\n                warning(reason, diff);\n                entity = null;\n              } else if (alphanumerical(following)) {\n                entity = null;\n              } else {\n                warning(reason, diff);\n              }\n            }\n          }\n        }\n\n        reference = entity;\n      } else {\n        if (!terminated) {\n          /* All non-terminated numeric entities are\n           * not rendered, and trigger a warning. */\n          warning(NUMERIC_NOT_TERMINATED, diff);\n        }\n        /* When terminated and number, parse as\n         * either hexadecimal or decimal. */\n\n\n        reference = parseInt(characters, BASE[type]);\n        /* Trigger a warning when the parsed number\n         * is prohibited, and replace with\n         * replacement character. */\n\n        if (prohibited(reference)) {\n          warning(NUMERIC_PROHIBITED, diff);\n          reference = '\\uFFFD';\n        } else if (reference in invalid) {\n          /* Trigger a warning when the parsed number\n           * is disallowed, and replace by an\n           * alternative. */\n          warning(NUMERIC_DISALLOWED, diff);\n          reference = invalid[reference];\n        } else {\n          /* Parse the number. */\n          output = '';\n          /* Trigger a warning when the parsed\n           * number should not be used. */\n\n          if (disallowed(reference)) {\n            warning(NUMERIC_DISALLOWED, diff);\n          }\n          /* Stringify the number. */\n\n\n          if (reference > 0xffff) {\n            reference -= 0x10000;\n            output += fromCharCode(reference >>> (10 & 0x3ff) | 0xd800);\n            reference = 0xdc00 | reference & 0x3ff;\n          }\n\n          reference = output + fromCharCode(reference);\n        }\n      }\n      /* If we could not find a reference, queue the\n       * checked characters (as normal characters),\n       * and move the pointer to their end. This is\n       * possible because we can be certain neither\n       * newlines nor ampersands are included. */\n\n\n      if (!reference) {\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      } else {\n        /* Found it! First eat the queued\n         * characters as normal text, then eat\n         * an entity. */\n        flush();\n        prev = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        next = now();\n        next.offset++;\n\n        if (handleReference) {\n          handleReference.call(referenceContext, reference, {\n            start: prev,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n\n        prev = next;\n      }\n    }\n  }\n  /* Return the reduced nodes, and any possible warnings. */\n\n\n  return result.join('');\n  /* Get current position. */\n\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    };\n  }\n  /* “Throw” a parse-error: a warning. */\n\n\n  function parseError(code, offset) {\n    var position = now();\n    position.column += offset;\n    position.offset += offset;\n    handleWarning.call(warningContext, MESSAGES[code], position, code);\n  }\n  /* Get character at position. */\n\n\n  function at(position) {\n    return value.charAt(position);\n  }\n  /* Flush `queue` (normal text). Macro invoked before\n   * each entity and at the end of `value`.\n   * Does nothing when `queue` is empty. */\n\n\n  function flush() {\n    if (queue) {\n      result.push(queue);\n\n      if (handleText) {\n        handleText.call(textContext, queue, {\n          start: prev,\n          end: now()\n        });\n      }\n\n      queue = '';\n    }\n  }\n}\n/* Check if `character` is outside the permissible unicode range. */\n\n\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/* Check if `character` is disallowed. */\n\n\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/parse-entities/index.js"],"names":["legacy","require","invalid","decimal","hexadecimal","alphanumerical","decodeEntity","module","exports","parseEntities","own","hasOwnProperty","fromCharCode","String","noop","Function","prototype","defaults","warning","reference","text","warningContext","referenceContext","textContext","position","additional","attribute","nonTerminated","NAMED","HEXADECIMAL","DECIMAL","BASE","TESTS","NAMED_NOT_TERMINATED","NUMERIC_NOT_TERMINATED","NAMED_EMPTY","NUMERIC_EMPTY","NAMED_UNKNOWN","NUMERIC_DISALLOWED","NUMERIC_PROHIBITED","MESSAGES","value","options","settings","option","key","undefined","indent","start","parse","handleText","handleReference","handleWarning","pos","length","index","lines","column","line","queue","result","entityCharacters","namedEntity","terminated","characters","character","following","reason","output","entity","begin","type","test","prev","next","diff","end","now","parseError","at","flush","call","parseInt","prohibited","disallowed","slice","push","offset","join","code","charAt"],"mappings":"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","sourcesContent":["'use strict'\n\nvar legacy = require('character-entities-legacy')\nvar invalid = require('character-reference-invalid')\nvar decimal = require('is-decimal')\nvar hexadecimal = require('is-hexadecimal')\nvar alphanumerical = require('is-alphanumerical')\nvar decodeEntity = require('./decode-entity')\n\nmodule.exports = parseEntities\n\nvar own = {}.hasOwnProperty\nvar fromCharCode = String.fromCharCode\nvar noop = Function.prototype\n\n/* Default settings. */\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n}\n\n/* Reference types. */\nvar NAMED = 'named'\nvar HEXADECIMAL = 'hexadecimal'\nvar DECIMAL = 'decimal'\n\n/* Map of bases. */\nvar BASE = {}\n\nBASE[HEXADECIMAL] = 16\nBASE[DECIMAL] = 10\n\n/* Map of types to tests. Each type of character reference\n * accepts different characters. This test is used to\n * detect whether a reference has ended (as the semicolon\n * is not strictly needed). */\nvar TESTS = {}\n\nTESTS[NAMED] = alphanumerical\nTESTS[DECIMAL] = decimal\nTESTS[HEXADECIMAL] = hexadecimal\n\n/* Warning messages. */\nvar NAMED_NOT_TERMINATED = 1\nvar NUMERIC_NOT_TERMINATED = 2\nvar NAMED_EMPTY = 3\nvar NUMERIC_EMPTY = 4\nvar NAMED_UNKNOWN = 5\nvar NUMERIC_DISALLOWED = 6\nvar NUMERIC_PROHIBITED = 7\n\nvar MESSAGES = {}\n\nMESSAGES[NAMED_NOT_TERMINATED] =\n  'Named character references must be terminated by a semicolon'\nMESSAGES[NUMERIC_NOT_TERMINATED] =\n  'Numeric character references must be terminated by a semicolon'\nMESSAGES[NAMED_EMPTY] = 'Named character references cannot be empty'\nMESSAGES[NUMERIC_EMPTY] = 'Numeric character references cannot be empty'\nMESSAGES[NAMED_UNKNOWN] = 'Named character references must be known'\nMESSAGES[NUMERIC_DISALLOWED] =\n  'Numeric character references cannot be disallowed'\nMESSAGES[NUMERIC_PROHIBITED] =\n  'Numeric character references cannot be outside the permissible Unicode range'\n\n/* Wrap to ensure clean parameters are given to `parse`. */\nfunction parseEntities(value, options) {\n  var settings = {}\n  var option\n  var key\n\n  if (!options) {\n    options = {}\n  }\n\n  for (key in defaults) {\n    option = options[key]\n    settings[key] =\n      option === null || option === undefined ? defaults[key] : option\n  }\n\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || []\n    settings.position = settings.position.start\n  }\n\n  return parse(value, settings)\n}\n\n/* Parse entities. */\nfunction parse(value, settings) {\n  var additional = settings.additional\n  var nonTerminated = settings.nonTerminated\n  var handleText = settings.text\n  var handleReference = settings.reference\n  var handleWarning = settings.warning\n  var textContext = settings.textContext\n  var referenceContext = settings.referenceContext\n  var warningContext = settings.warningContext\n  var pos = settings.position\n  var indent = settings.indent || []\n  var length = value.length\n  var index = 0\n  var lines = -1\n  var column = pos.column || 1\n  var line = pos.line || 1\n  var queue = ''\n  var result = []\n  var entityCharacters\n  var namedEntity\n  var terminated\n  var characters\n  var character\n  var reference\n  var following\n  var warning\n  var reason\n  var output\n  var entity\n  var begin\n  var start\n  var type\n  var test\n  var prev\n  var next\n  var diff\n  var end\n\n  /* Cache the current point. */\n  prev = now()\n\n  /* Wrap `handleWarning`. */\n  warning = handleWarning ? parseError : noop\n\n  /* Ensure the algorithm walks over the first character\n   * and the end (inclusive). */\n  index--\n  length++\n\n  while (++index < length) {\n    /* If the previous character was a newline. */\n    if (character === '\\n') {\n      column = indent[lines] || 1\n    }\n\n    character = at(index)\n\n    /* Handle anything other than an ampersand,\n     * including newlines and EOF. */\n    if (character !== '&') {\n      if (character === '\\n') {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (character) {\n        queue += character\n        column++\n      } else {\n        flush()\n      }\n    } else {\n      following = at(index + 1)\n\n      /* The behaviour depends on the identity of the next\n       * character. */\n      if (\n        following === '\\t' /* Tab */ ||\n        following === '\\n' /* Newline */ ||\n        following === '\\f' /* Form feed */ ||\n        following === ' ' /* Space */ ||\n        following === '<' /* Less-than */ ||\n        following === '&' /* Ampersand */ ||\n        following === '' ||\n        (additional && following === additional)\n      ) {\n        /* Not a character reference. No characters\n         * are consumed, and nothing is returned.\n         * This is not an error, either. */\n        queue += character\n        column++\n\n        continue\n      }\n\n      start = index + 1\n      begin = start\n      end = start\n\n      /* Numerical entity. */\n      if (following !== '#') {\n        type = NAMED\n      } else {\n        end = ++begin\n\n        /* The behaviour further depends on the\n         * character after the U+0023 NUMBER SIGN. */\n        following = at(end)\n\n        if (following === 'x' || following === 'X') {\n          /* ASCII hex digits. */\n          type = HEXADECIMAL\n          end = ++begin\n        } else {\n          /* ASCII digits. */\n          type = DECIMAL\n        }\n      }\n\n      entityCharacters = ''\n      entity = ''\n      characters = ''\n      test = TESTS[type]\n      end--\n\n      while (++end < length) {\n        following = at(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += following\n\n        /* Check if we can match a legacy named\n         * reference.  If so, we cache that as the\n         * last viable named reference.  This\n         * ensures we do not need to walk backwards\n         * later. */\n        if (type === NAMED && own.call(legacy, characters)) {\n          entityCharacters = characters\n          entity = legacy[characters]\n        }\n      }\n\n      terminated = at(end) === ';'\n\n      if (terminated) {\n        end++\n\n        namedEntity = type === NAMED ? decodeEntity(characters) : false\n\n        if (namedEntity) {\n          entityCharacters = characters\n          entity = namedEntity\n        }\n      }\n\n      diff = 1 + end - start\n\n      if (!terminated && !nonTerminated) {\n        /* Empty. */\n      } else if (!characters) {\n        /* An empty (possible) entity is valid, unless\n         * its numeric (thus an ampersand followed by\n         * an octothorp). */\n        if (type !== NAMED) {\n          warning(NUMERIC_EMPTY, diff)\n        }\n      } else if (type === NAMED) {\n        /* An ampersand followed by anything\n         * unknown, and not terminated, is invalid. */\n        if (terminated && !entity) {\n          warning(NAMED_UNKNOWN, 1)\n        } else {\n          /* If theres something after an entity\n           * name which is not known, cap the\n           * reference. */\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          /* If the reference is not terminated,\n           * warn. */\n          if (!terminated) {\n            reason = entityCharacters ? NAMED_NOT_TERMINATED : NAMED_EMPTY\n\n            if (!settings.attribute) {\n              warning(reason, diff)\n            } else {\n              following = at(end)\n\n              if (following === '=') {\n                warning(reason, diff)\n                entity = null\n              } else if (alphanumerical(following)) {\n                entity = null\n              } else {\n                warning(reason, diff)\n              }\n            }\n          }\n        }\n\n        reference = entity\n      } else {\n        if (!terminated) {\n          /* All non-terminated numeric entities are\n           * not rendered, and trigger a warning. */\n          warning(NUMERIC_NOT_TERMINATED, diff)\n        }\n\n        /* When terminated and number, parse as\n         * either hexadecimal or decimal. */\n        reference = parseInt(characters, BASE[type])\n\n        /* Trigger a warning when the parsed number\n         * is prohibited, and replace with\n         * replacement character. */\n        if (prohibited(reference)) {\n          warning(NUMERIC_PROHIBITED, diff)\n          reference = '\\uFFFD'\n        } else if (reference in invalid) {\n          /* Trigger a warning when the parsed number\n           * is disallowed, and replace by an\n           * alternative. */\n          warning(NUMERIC_DISALLOWED, diff)\n          reference = invalid[reference]\n        } else {\n          /* Parse the number. */\n          output = ''\n\n          /* Trigger a warning when the parsed\n           * number should not be used. */\n          if (disallowed(reference)) {\n            warning(NUMERIC_DISALLOWED, diff)\n          }\n\n          /* Stringify the number. */\n          if (reference > 0xffff) {\n            reference -= 0x10000\n            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800)\n            reference = 0xdc00 | (reference & 0x3ff)\n          }\n\n          reference = output + fromCharCode(reference)\n        }\n      }\n\n      /* If we could not find a reference, queue the\n       * checked characters (as normal characters),\n       * and move the pointer to their end. This is\n       * possible because we can be certain neither\n       * newlines nor ampersands are included. */\n      if (!reference) {\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      } else {\n        /* Found it! First eat the queued\n         * characters as normal text, then eat\n         * an entity. */\n        flush()\n\n        prev = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        next = now()\n        next.offset++\n\n        if (handleReference) {\n          handleReference.call(\n            referenceContext,\n            reference,\n            {start: prev, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        prev = next\n      }\n    }\n  }\n\n  /* Return the reduced nodes, and any possible warnings. */\n  return result.join('')\n\n  /* Get current position. */\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    }\n  }\n\n  /* “Throw” a parse-error: a warning. */\n  function parseError(code, offset) {\n    var position = now()\n\n    position.column += offset\n    position.offset += offset\n\n    handleWarning.call(warningContext, MESSAGES[code], position, code)\n  }\n\n  /* Get character at position. */\n  function at(position) {\n    return value.charAt(position)\n  }\n\n  /* Flush `queue` (normal text). Macro invoked before\n   * each entity and at the end of `value`.\n   * Does nothing when `queue` is empty. */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (handleText) {\n        handleText.call(textContext, queue, {start: prev, end: now()})\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/* Check if `character` is outside the permissible unicode range. */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/* Check if `character` is disallowed. */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n"]},"metadata":{},"sourceType":"script"}