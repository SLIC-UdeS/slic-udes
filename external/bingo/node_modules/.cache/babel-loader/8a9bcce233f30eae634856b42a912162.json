{"ast":null,"code":"'use strict';\n\nvar slice = [].slice;\nmodule.exports = wrap;\n/* Wrap `fn`.  Can be sync or async; return a promise,\n * receive a completion handler, return new values and\n * errors. */\n\nfunction wrap(fn, callback) {\n  var invoked;\n  return wrapped;\n\n  function wrapped() {\n    var params = slice.call(arguments, 0);\n    var callback = fn.length > params.length;\n    var result;\n\n    if (callback) {\n      params.push(done);\n    }\n\n    try {\n      result = fn.apply(null, params);\n    } catch (err) {\n      /* Well, this is quite the pickle.  `fn` received\n       * a callback and invoked it (thus continuing the\n       * pipeline), but later also threw an error.\n       * We’re not about to restart the pipeline again,\n       * so the only thing left to do is to throw the\n       * thing instea. */\n      if (callback && invoked) {\n        throw err;\n      }\n\n      return done(err);\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /* Invoke `next`, only once. */\n\n\n  function done() {\n    if (!invoked) {\n      invoked = true;\n      callback.apply(null, arguments);\n    }\n  }\n  /* Invoke `done` with one value.\n   * Tracks if an error is passed, too. */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/trough/wrap.js"],"names":["slice","module","exports","wrap","fn","callback","invoked","wrapped","params","call","arguments","length","result","push","done","apply","err","then","Error","value"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAG,GAAGA,KAAf;AAEAC,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AAEA;;;;AAGA,SAASA,IAAT,CAAcC,EAAd,EAAkBC,QAAlB,EAA4B;AAC1B,MAAIC,OAAJ;AAEA,SAAOC,OAAP;;AAEA,WAASA,OAAT,GAAmB;AACjB,QAAIC,MAAM,GAAGR,KAAK,CAACS,IAAN,CAAWC,SAAX,EAAsB,CAAtB,CAAb;AACA,QAAIL,QAAQ,GAAGD,EAAE,CAACO,MAAH,GAAYH,MAAM,CAACG,MAAlC;AACA,QAAIC,MAAJ;;AAEA,QAAIP,QAAJ,EAAc;AACZG,MAAAA,MAAM,CAACK,IAAP,CAAYC,IAAZ;AACD;;AAED,QAAI;AACFF,MAAAA,MAAM,GAAGR,EAAE,CAACW,KAAH,CAAS,IAAT,EAAeP,MAAf,CAAT;AACD,KAFD,CAEE,OAAOQ,GAAP,EAAY;AACZ;;;;;;AAMA,UAAIX,QAAQ,IAAIC,OAAhB,EAAyB;AACvB,cAAMU,GAAN;AACD;;AAED,aAAOF,IAAI,CAACE,GAAD,CAAX;AACD;;AAED,QAAI,CAACX,QAAL,EAAe;AACb,UAAIO,MAAM,IAAI,OAAOA,MAAM,CAACK,IAAd,KAAuB,UAArC,EAAiD;AAC/CL,QAAAA,MAAM,CAACK,IAAP,CAAYA,IAAZ,EAAkBH,IAAlB;AACD,OAFD,MAEO,IAAIF,MAAM,YAAYM,KAAtB,EAA6B;AAClCJ,QAAAA,IAAI,CAACF,MAAD,CAAJ;AACD,OAFM,MAEA;AACLK,QAAAA,IAAI,CAACL,MAAD,CAAJ;AACD;AACF;AACF;AAED;;;AACA,WAASE,IAAT,GAAgB;AACd,QAAI,CAACR,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,IAAV;AAEAD,MAAAA,QAAQ,CAACU,KAAT,CAAe,IAAf,EAAqBL,SAArB;AACD;AACF;AAED;;;;AAEA,WAASO,IAAT,CAAcE,KAAd,EAAqB;AACnBL,IAAAA,IAAI,CAAC,IAAD,EAAOK,KAAP,CAAJ;AACD;AACF","sourcesContent":["'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n/* Wrap `fn`.  Can be sync or async; return a promise,\n * receive a completion handler, return new values and\n * errors. */\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (err) {\n      /* Well, this is quite the pickle.  `fn` received\n       * a callback and invoked it (thus continuing the\n       * pipeline), but later also threw an error.\n       * We’re not about to restart the pipeline again,\n       * so the only thing left to do is to throw the\n       * thing instea. */\n      if (callback && invoked) {\n        throw err\n      }\n\n      return done(err)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /* Invoke `next`, only once. */\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  /* Invoke `done` with one value.\n   * Tracks if an error is passed, too. */\n  function then(value) {\n    done(null, value)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}