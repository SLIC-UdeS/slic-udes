{"ast":null,"code":"'use strict';\n/* eslint-disable max-params */\n\n/* Expose. */\n\nmodule.exports = is;\n/* Assert if `test` passes for `node`.\n * When a `parent` node is known the `index` of node */\n\nfunction is(test, node, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined;\n  var hasIndex = index !== null && index !== undefined;\n  var check = convert(test);\n\n  if (hasIndex && (typeof index !== 'number' || index < 0 || index === Infinity)) {\n    throw new Error('Expected positive finite index or child node');\n  }\n\n  if (hasParent && (!is(null, parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false;\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index');\n  }\n\n  return Boolean(check.call(context, node, index, parent));\n}\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (test === null || test === undefined) {\n    return ok;\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test);\n  }\n\n  if (typeof test === 'function') {\n    return test;\n  }\n\n  throw new Error('Expected function, string, or object as test');\n}\n\nfunction convertAll(tests) {\n  var results = [];\n  var length = tests.length;\n  var index = -1;\n\n  while (++index < length) {\n    results[index] = convert(tests[index]);\n  }\n\n  return results;\n}\n/* Utility assert each property in `test` is represented\n * in `node`, and each values are strictly equal. */\n\n\nfunction matchesFactory(test) {\n  return matches;\n\n  function matches(node) {\n    var key;\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests);\n  var length = checks.length;\n  return matches;\n\n  function matches() {\n    var index = -1;\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n/* Utility to convert a string into a function which checks\n * a given node’s type for said string. */\n\n\nfunction typeFactory(test) {\n  return type;\n\n  function type(node) {\n    return Boolean(node && node.type === test);\n  }\n}\n/* Utility to return true. */\n\n\nfunction ok() {\n  return true;\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/unist-util-is/index.js"],"names":["module","exports","is","test","node","index","parent","context","hasParent","undefined","hasIndex","check","convert","Infinity","Error","children","type","Boolean","call","typeFactory","ok","anyFactory","matchesFactory","convertAll","tests","results","length","matches","key","checks","apply","arguments"],"mappings":"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","sourcesContent":["'use strict'\n\n/* eslint-disable max-params */\n\n/* Expose. */\nmodule.exports = is\n\n/* Assert if `test` passes for `node`.\n * When a `parent` node is known the `index` of node */\nfunction is(test, node, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined\n  var hasIndex = index !== null && index !== undefined\n  var check = convert(test)\n\n  if (\n    hasIndex &&\n    (typeof index !== 'number' || index < 0 || index === Infinity)\n  ) {\n    throw new Error('Expected positive finite index or child node')\n  }\n\n  if (hasParent && (!is(null, parent) || !parent.children)) {\n    throw new Error('Expected parent node')\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index')\n  }\n\n  return Boolean(check.call(context, node, index, parent))\n}\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return ok\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\nfunction convertAll(tests) {\n  var results = []\n  var length = tests.length\n  var index = -1\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\n/* Utility assert each property in `test` is represented\n * in `node`, and each values are strictly equal. */\nfunction matchesFactory(test) {\n  return matches\n\n  function matches(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/* Utility to convert a string into a function which checks\n * a given node’s type for said string. */\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n/* Utility to return true. */\nfunction ok() {\n  return true\n}\n"]},"metadata":{},"sourceType":"script"}