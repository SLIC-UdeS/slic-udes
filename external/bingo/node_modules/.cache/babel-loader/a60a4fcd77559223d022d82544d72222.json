{"ast":null,"code":"/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // enviroments that support module.exports, like Node.\n    try {\n      module.exports = factory(require('moment'));\n    } catch (e) {\n      // If moment is not available, leave the setup up to the user.\n      // Like when using moment-timezone or similar moment-based package.\n      module.exports = factory;\n    }\n  }\n\n  if (root) {\n    // Globals.\n    root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n  }\n})(this, function (moment) {\n  // `Number#tolocaleString` is tested on plugin initialization.\n  // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n  // native function will be used to generate formatted output. If the feature\n  // test fails, the fallback format function internal to this plugin will be\n  // used.\n  var toLocaleStringWorks = false; // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `toLocaleString` will be used for formatting,\n  // the plugin will \"pre-round\" number values using the fallback number format\n  // function before passing them to `toLocaleString` for final formatting.\n\n  var toLocaleStringRoundingWorks = false; // Token type names in order of descending magnitude.\n\n  var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n  var bubbles = [{\n    type: \"seconds\",\n    targets: [{\n      type: \"minutes\",\n      value: 60\n    }, {\n      type: \"hours\",\n      value: 3600\n    }, {\n      type: \"days\",\n      value: 86400\n    }, {\n      type: \"weeks\",\n      value: 604800\n    }, {\n      type: \"months\",\n      value: 2678400\n    }, {\n      type: \"years\",\n      value: 31536000\n    }]\n  }, {\n    type: \"minutes\",\n    targets: [{\n      type: \"hours\",\n      value: 60\n    }, {\n      type: \"days\",\n      value: 1440\n    }, {\n      type: \"weeks\",\n      value: 10080\n    }, {\n      type: \"months\",\n      value: 44640\n    }, {\n      type: \"years\",\n      value: 525600\n    }]\n  }, {\n    type: \"hours\",\n    targets: [{\n      type: \"days\",\n      value: 24\n    }, {\n      type: \"weeks\",\n      value: 168\n    }, {\n      type: \"months\",\n      value: 744\n    }, {\n      type: \"years\",\n      value: 8760\n    }]\n  }, {\n    type: \"days\",\n    targets: [{\n      type: \"weeks\",\n      value: 7\n    }, {\n      type: \"months\",\n      value: 31\n    }, {\n      type: \"years\",\n      value: 365\n    }]\n  }, {\n    type: \"months\",\n    targets: [{\n      type: \"years\",\n      value: 12\n    }]\n  }]; // stringIncludes\n\n  function stringIncludes(str, search) {\n    if (search.length > str.length) {\n      return false;\n    }\n\n    return str.indexOf(search) !== -1;\n  } // repeatZero(qty)\n  // Returns \"0\" repeated `qty` times.\n  // `qty` must be a integer >= 0.\n\n\n  function repeatZero(qty) {\n    var result = \"\";\n\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n\n    return result;\n  }\n\n  function stringRound(digits) {\n    var digitsArray = digits.split(\"\").reverse();\n    var i = 0;\n    var carry = true;\n\n    while (carry && i < digitsArray.length) {\n      if (i) {\n        if (digitsArray[i] === \"9\") {\n          digitsArray[i] = \"0\";\n        } else {\n          digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n          carry = false;\n        }\n      } else {\n        if (parseInt(digitsArray[i], 10) < 5) {\n          carry = false;\n        }\n\n        digitsArray[i] = \"0\";\n      }\n\n      i += 1;\n    }\n\n    if (carry) {\n      digitsArray.push(\"1\");\n    }\n\n    return digitsArray.reverse().join(\"\");\n  } // formatNumber\n  // Formats any number greater than or equal to zero using these options:\n  // - userLocale\n  // - useToLocaleString\n  // - useGrouping\n  // - grouping\n  // - maximumSignificantDigits\n  // - minimumIntegerDigits\n  // - fractionDigits\n  // - groupingSeparator\n  // - decimalSeparator\n  //\n  // `useToLocaleString` will use `toLocaleString` for formatting.\n  // `userLocale` option is passed through to `toLocaleString`.\n  // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n  // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n\n\n  function formatNumber(number, options, userLocale) {\n    var useToLocaleString = options.useToLocaleString;\n    var useGrouping = options.useGrouping;\n    var grouping = useGrouping && options.grouping.slice();\n    var maximumSignificantDigits = options.maximumSignificantDigits;\n    var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n    var fractionDigits = options.fractionDigits || 0;\n    var groupingSeparator = options.groupingSeparator;\n    var decimalSeparator = options.decimalSeparator;\n\n    if (useToLocaleString && userLocale) {\n      var localeStringOptions = {\n        minimumIntegerDigits: minimumIntegerDigits,\n        useGrouping: useGrouping\n      };\n\n      if (fractionDigits) {\n        localeStringOptions.maximumFractionDigits = fractionDigits;\n        localeStringOptions.minimumFractionDigits = fractionDigits;\n      } // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n      // when maximumSignificantDigits is set. See #96.\n\n\n      if (maximumSignificantDigits && number > 0) {\n        localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n      }\n\n      if (!toLocaleStringRoundingWorks) {\n        var roundingOptions = extend({}, options);\n        roundingOptions.useGrouping = false;\n        roundingOptions.decimalSeparator = \".\";\n        number = parseFloat(formatNumber(number, roundingOptions), 10);\n      }\n\n      return number.toLocaleString(userLocale, localeStringOptions);\n    }\n\n    var numberString; // Add 1 to digit output length for floating point errors workaround. See below.\n\n    if (maximumSignificantDigits) {\n      numberString = number.toPrecision(maximumSignificantDigits + 1);\n    } else {\n      numberString = number.toFixed(fractionDigits + 1);\n    }\n\n    var integerString;\n    var fractionString;\n    var exponentString;\n    var temp = numberString.split(\"e\");\n    exponentString = temp[1] || \"\";\n    temp = temp[0].split(\".\");\n    fractionString = temp[1] || \"\";\n    integerString = temp[0] || \"\"; // Workaround for floating point errors in `toFixed` and `toPrecision`.\n    // (3.55).toFixed(1); --> \"3.5\"\n    // (123.55 - 120).toPrecision(2); --> \"3.5\"\n    // (123.55 - 120); --> 3.549999999999997\n    // (123.55 - 120).toFixed(2); --> \"3.55\"\n    // Round by examing the string output of the next digit.\n    // *************** Implement String Rounding here ***********************\n    // Check integerString + fractionString length of toPrecision before rounding.\n    // Check length of fractionString from toFixed output before rounding.\n\n    var integerLength = integerString.length;\n    var fractionLength = fractionString.length;\n    var digitCount = integerLength + fractionLength;\n    var digits = integerString + fractionString;\n\n    if (maximumSignificantDigits && digitCount === maximumSignificantDigits + 1 || !maximumSignificantDigits && fractionLength === fractionDigits + 1) {\n      // Round digits.\n      digits = stringRound(digits);\n\n      if (digits.length === digitCount + 1) {\n        integerLength = integerLength + 1;\n      } // Discard final fractionDigit.\n\n\n      if (fractionLength) {\n        digits = digits.slice(0, -1);\n      } // Separate integer and fraction.\n\n\n      integerString = digits.slice(0, integerLength);\n      fractionString = digits.slice(integerLength);\n    } // Trim trailing zeroes from fractionString because toPrecision outputs\n    // precision, not significant digits.\n\n\n    if (maximumSignificantDigits) {\n      fractionString = fractionString.replace(/0*$/, \"\");\n    } // Handle exponent.\n\n\n    var exponent = parseInt(exponentString, 10);\n\n    if (exponent > 0) {\n      if (fractionString.length <= exponent) {\n        fractionString = fractionString + repeatZero(exponent - fractionString.length);\n        integerString = integerString + fractionString;\n        fractionString = \"\";\n      } else {\n        integerString = integerString + fractionString.slice(0, exponent);\n        fractionString = fractionString.slice(exponent);\n      }\n    } else if (exponent < 0) {\n      fractionString = repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString;\n      integerString = \"0\";\n    }\n\n    if (!maximumSignificantDigits) {\n      // Trim or pad fraction when not using maximumSignificantDigits.\n      fractionString = fractionString.slice(0, fractionDigits);\n\n      if (fractionString.length < fractionDigits) {\n        fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n      } // Pad integer when using minimumIntegerDigits\n      // and not using maximumSignificantDigits.\n\n\n      if (integerString.length < minimumIntegerDigits) {\n        integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n      }\n    }\n\n    var formattedString = \"\"; // Handle grouping.\n\n    if (useGrouping) {\n      temp = integerString;\n      var group;\n\n      while (temp.length) {\n        if (grouping.length) {\n          group = grouping.shift();\n        }\n\n        if (formattedString) {\n          formattedString = groupingSeparator + formattedString;\n        }\n\n        formattedString = temp.slice(-group) + formattedString;\n        temp = temp.slice(0, -group);\n      }\n    } else {\n      formattedString = integerString;\n    } // Add decimalSeparator and fraction.\n\n\n    if (fractionString) {\n      formattedString = formattedString + decimalSeparator + fractionString;\n    }\n\n    return formattedString;\n  } // durationLabelCompare\n\n\n  function durationLabelCompare(a, b) {\n    if (a.label.length > b.label.length) {\n      return -1;\n    }\n\n    if (a.label.length < b.label.length) {\n      return 1;\n    } // a must be equal to b\n\n\n    return 0;\n  } // durationGetLabels\n\n\n  function durationGetLabels(token, localeData) {\n    var labels = [];\n    each(keys(localeData), function (localeDataKey) {\n      if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n        return;\n      }\n\n      var labelType = localeDataKey.slice(15).toLowerCase();\n      each(keys(localeData[localeDataKey]), function (labelKey) {\n        if (labelKey.slice(0, 1) === token) {\n          labels.push({\n            type: labelType,\n            key: labelKey,\n            label: localeData[localeDataKey][labelKey]\n          });\n        }\n      });\n    });\n    return labels;\n  } // durationPluralKey\n\n\n  function durationPluralKey(token, integerValue, decimalValue) {\n    // Singular for a value of `1`, but not for `1.0`.\n    if (integerValue === 1 && decimalValue === null) {\n      return token;\n    }\n\n    return token + token;\n  }\n\n  var engLocale = {\n    durationLabelsStandard: {\n      S: 'millisecond',\n      SS: 'milliseconds',\n      s: 'second',\n      ss: 'seconds',\n      m: 'minute',\n      mm: 'minutes',\n      h: 'hour',\n      hh: 'hours',\n      d: 'day',\n      dd: 'days',\n      w: 'week',\n      ww: 'weeks',\n      M: 'month',\n      MM: 'months',\n      y: 'year',\n      yy: 'years'\n    },\n    durationLabelsShort: {\n      S: 'msec',\n      SS: 'msecs',\n      s: 'sec',\n      ss: 'secs',\n      m: 'min',\n      mm: 'mins',\n      h: 'hr',\n      hh: 'hrs',\n      d: 'dy',\n      dd: 'dys',\n      w: 'wk',\n      ww: 'wks',\n      M: 'mo',\n      MM: 'mos',\n      y: 'yr',\n      yy: 'yrs'\n    },\n    durationTimeTemplates: {\n      HMS: 'h:mm:ss',\n      HM: 'h:mm',\n      MS: 'm:ss'\n    },\n    durationLabelTypes: [{\n      type: \"standard\",\n      string: \"__\"\n    }, {\n      type: \"short\",\n      string: \"_\"\n    }],\n    durationPluralKey: durationPluralKey\n  }; // isArray\n\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  } // isObject\n\n\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  } // findLast\n\n\n  function findLast(array, callback) {\n    var index = array.length;\n\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  } // find\n\n\n  function find(array, callback) {\n    var index = 0;\n    var max = array && array.length || 0;\n    var match;\n\n    if (typeof callback !== \"function\") {\n      match = callback;\n\n      callback = function callback(item) {\n        return item === match;\n      };\n    }\n\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n\n      index += 1;\n    }\n  } // each\n\n\n  function each(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n\n      index += 1;\n    }\n  } // map\n\n\n  function map(array, callback) {\n    var index = 0,\n        max = array.length,\n        ret = [];\n\n    if (!array || !max) {\n      return ret;\n    }\n\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n\n    return ret;\n  } // pluck\n\n\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  } // compact\n\n\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  } // unique\n\n\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  } // intersection\n\n\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  } // rest\n\n\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  } // initial\n\n\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  } // extend\n\n\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n\n    return a;\n  } // keys\n\n\n  function keys(a) {\n    var ret = [];\n\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        ret.push(key);\n      }\n    }\n\n    return ret;\n  } // any\n\n\n  function any(array, callback) {\n    var index = 0,\n        max = array.length;\n\n    if (!array || !max) {\n      return false;\n    }\n\n    while (index < max) {\n      if (callback(array[index], index) === true) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return false;\n  } // flatten\n\n\n  function flatten(array) {\n    var ret = [];\n    each(array, function (child) {\n      ret = ret.concat(child);\n    });\n    return ret;\n  }\n\n  function toLocaleStringSupportsLocales() {\n    var number = 0;\n\n    try {\n      number.toLocaleString('i');\n    } catch (e) {\n      return e.name === 'RangeError';\n    }\n\n    return false;\n  }\n\n  function featureTestToLocaleStringRounding() {\n    return 3.55.toLocaleString(\"en\", {\n      useGrouping: false,\n      minimumIntegerDigits: 1,\n      minimumFractionDigits: 1,\n      maximumFractionDigits: 1\n    }) === \"3.6\";\n  }\n\n  function featureTestToLocaleString() {\n    var passed = true; // Test locale.\n\n    passed = passed && toLocaleStringSupportsLocales();\n\n    if (!passed) {\n      return false;\n    } // Test minimumIntegerDigits.\n\n\n    passed = passed && 1 .toLocaleString(\"en\", {\n      minimumIntegerDigits: 1\n    }) === \"1\";\n    passed = passed && 1 .toLocaleString(\"en\", {\n      minimumIntegerDigits: 2\n    }) === \"01\";\n    passed = passed && 1 .toLocaleString(\"en\", {\n      minimumIntegerDigits: 3\n    }) === \"001\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumFractionDigits and minimumFractionDigits.\n\n\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumFractionDigits: 0,\n      minimumFractionDigits: 0\n    }) === \"100\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumFractionDigits: 1,\n      minimumFractionDigits: 1\n    }) === \"100.0\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 2\n    }) === \"99.99\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumFractionDigits: 3,\n      minimumFractionDigits: 3\n    }) === \"99.990\";\n\n    if (!passed) {\n      return false;\n    } // Test maximumSignificantDigits.\n\n\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumSignificantDigits: 1\n    }) === \"100\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumSignificantDigits: 2\n    }) === \"100\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumSignificantDigits: 3\n    }) === \"100\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumSignificantDigits: 4\n    }) === \"99.99\";\n    passed = passed && 99.99.toLocaleString(\"en\", {\n      maximumSignificantDigits: 5\n    }) === \"99.99\";\n\n    if (!passed) {\n      return false;\n    } // Test grouping.\n\n\n    passed = passed && 1000 .toLocaleString(\"en\", {\n      useGrouping: true\n    }) === \"1,000\";\n    passed = passed && 1000 .toLocaleString(\"en\", {\n      useGrouping: false\n    }) === \"1000\";\n\n    if (!passed) {\n      return false;\n    }\n\n    return true;\n  } // durationsFormat(durations [, template] [, precision] [, settings])\n\n\n  function durationsFormat() {\n    var args = [].slice.call(arguments);\n    var settings = {};\n    var durations; // Parse arguments.\n\n    each(args, function (arg, index) {\n      if (!index) {\n        if (!isArray(arg)) {\n          throw \"Expected array as the first argument to durationsFormat.\";\n        }\n\n        durations = arg;\n      }\n\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n\n    if (!durations || !durations.length) {\n      return [];\n    }\n\n    settings.returnMomentTypes = true;\n    var formattedDurations = map(durations, function (dur) {\n      return dur.format(settings);\n    }); // Merge token types from all durations.\n\n    var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n    var largest = settings.largest;\n\n    if (largest) {\n      outputTypes = outputTypes.slice(0, largest);\n    }\n\n    settings.returnMomentTypes = false;\n    settings.outputTypes = outputTypes;\n    return map(durations, function (dur) {\n      return dur.format(settings);\n    });\n  } // durationFormat([template] [, precision] [, settings])\n\n\n  function durationFormat() {\n    var args = [].slice.call(arguments);\n    var settings = extend({}, this.format.defaults); // Keep a shadow copy of this moment for calculating remainders.\n    // Perform all calculations on positive duration value, handle negative\n    // sign at the very end.\n\n    var asMilliseconds = this.asMilliseconds();\n    var asMonths = this.asMonths(); // Treat invalid durations as having a value of 0 milliseconds.\n\n    if (typeof this.isValid === \"function\" && this.isValid() === false) {\n      asMilliseconds = 0;\n      asMonths = 0;\n    }\n\n    var isNegative = asMilliseconds < 0; // Two shadow copies are needed because of the way moment.js handles\n    // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n\n    var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n    var remainderMonths = moment.duration(Math.abs(asMonths), \"months\"); // Parse arguments.\n\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    var momentTokens = {\n      years: \"y\",\n      months: \"M\",\n      weeks: \"w\",\n      days: \"d\",\n      hours: \"h\",\n      minutes: \"m\",\n      seconds: \"s\",\n      milliseconds: \"S\"\n    };\n    var tokenDefs = {\n      escape: /\\[(.+?)\\]/,\n      years: /\\*?[Yy]+/,\n      months: /\\*?M+/,\n      weeks: /\\*?[Ww]+/,\n      days: /\\*?[Dd]+/,\n      hours: /\\*?[Hh]+/,\n      minutes: /\\*?m+/,\n      seconds: /\\*?s+/,\n      milliseconds: /\\*?S+/,\n      general: /.+?/\n    }; // Types array is available in the template function.\n\n    settings.types = types;\n\n    var typeMap = function typeMap(token) {\n      return find(types, function (type) {\n        return tokenDefs[type].test(token);\n      });\n    };\n\n    var tokenizer = new RegExp(map(types, function (type) {\n      return tokenDefs[type].source;\n    }).join(\"|\"), \"g\"); // Current duration object is available in the template function.\n\n    settings.duration = this; // Eval template function and cache template string.\n\n    var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template; // outputTypes and returnMomentTypes are settings to support durationsFormat().\n    // outputTypes is an array of moment token types that determines\n    // the tokens returned in formatted output. This option overrides\n    // trim, largest, stopTrim, etc.\n\n    var outputTypes = settings.outputTypes; // returnMomentTypes is a boolean that sets durationFormat to return\n    // the processed momentTypes instead of formatted output.\n\n    var returnMomentTypes = settings.returnMomentTypes;\n    var largest = settings.largest; // Setup stopTrim array of token types.\n\n    var stopTrim = [];\n\n    if (!outputTypes) {\n      if (isArray(settings.stopTrim)) {\n        settings.stopTrim = settings.stopTrim.join(\"\");\n      } // Parse stopTrim string to create token types array.\n\n\n      if (settings.stopTrim) {\n        each(settings.stopTrim.match(tokenizer), function (token) {\n          var type = typeMap(token);\n\n          if (type === \"escape\" || type === \"general\") {\n            return;\n          }\n\n          stopTrim.push(type);\n        });\n      }\n    } // Cache moment's locale data.\n\n\n    var localeData = moment.localeData();\n\n    if (!localeData) {\n      localeData = {};\n    } // Fall back to this plugin's `eng` extension.\n\n\n    each(keys(engLocale), function (key) {\n      if (typeof engLocale[key] === \"function\") {\n        if (!localeData[key]) {\n          localeData[key] = engLocale[key];\n        }\n\n        return;\n      }\n\n      if (!localeData[\"_\" + key]) {\n        localeData[\"_\" + key] = engLocale[key];\n      }\n    }); // Replace Duration Time Template strings.\n    // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n\n    each(keys(localeData._durationTimeTemplates), function (item) {\n      template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n    }); // Determine user's locale.\n\n    var userLocale = settings.userLocale || moment.locale();\n    var useLeftUnits = settings.useLeftUnits;\n    var usePlural = settings.usePlural;\n    var precision = settings.precision;\n    var forceLength = settings.forceLength;\n    var useGrouping = settings.useGrouping;\n    var trunc = settings.trunc; // Use significant digits only when precision is greater than 0.\n\n    var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n    var significantDigits = useSignificantDigits ? settings.precision : 0;\n    var significantDigitsCache = significantDigits;\n    var minValue = settings.minValue;\n    var isMinValue = false;\n    var maxValue = settings.maxValue;\n    var isMaxValue = false; // formatNumber fallback options.\n\n    var useToLocaleString = settings.useToLocaleString;\n    var groupingSeparator = settings.groupingSeparator;\n    var decimalSeparator = settings.decimalSeparator;\n    var grouping = settings.grouping;\n    useToLocaleString = useToLocaleString && toLocaleStringWorks; // Trim options.\n\n    var trim = settings.trim;\n\n    if (isArray(trim)) {\n      trim = trim.join(\" \");\n    }\n\n    if (trim === null && (largest || maxValue || useSignificantDigits)) {\n      trim = \"all\";\n    }\n\n    if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n      trim = \"large\";\n    }\n\n    if (trim === false) {\n      trim = \"\";\n    }\n\n    var trimIncludes = function trimIncludes(item) {\n      return item.test(trim);\n    };\n\n    var rLarge = /large/;\n    var rSmall = /small/;\n    var rBoth = /both/;\n    var rMid = /mid/;\n    var rAll = /^all|[^sm]all/;\n    var rFinal = /final/;\n    var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n    var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n    var trimMid = any([rMid, rAll], trimIncludes);\n    var trimFinal = any([rFinal, rAll], trimIncludes); // Parse format string to create raw tokens array.\n\n    var rawTokens = map(template.match(tokenizer), function (token, index) {\n      var type = typeMap(token);\n\n      if (token.slice(0, 1) === \"*\") {\n        token = token.slice(1);\n\n        if (type !== \"escape\" && type !== \"general\") {\n          stopTrim.push(type);\n        }\n      }\n\n      return {\n        index: index,\n        length: token.length,\n        text: \"\",\n        // Replace escaped tokens with the non-escaped token text.\n        token: type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token,\n        // Ignore type on non-moment tokens.\n        type: type === \"escape\" || type === \"general\" ? null : type\n      };\n    }); // Associate text tokens with moment tokens.\n\n    var currentToken = {\n      index: 0,\n      length: 0,\n      token: \"\",\n      text: \"\",\n      type: null\n    };\n    var tokens = [];\n\n    if (useLeftUnits) {\n      rawTokens.reverse();\n    }\n\n    each(rawTokens, function (token) {\n      if (token.type) {\n        if (currentToken.type || currentToken.text) {\n          tokens.push(currentToken);\n        }\n\n        currentToken = token;\n        return;\n      }\n\n      if (useLeftUnits) {\n        currentToken.text = token.token + currentToken.text;\n      } else {\n        currentToken.text += token.token;\n      }\n    });\n\n    if (currentToken.type || currentToken.text) {\n      tokens.push(currentToken);\n    }\n\n    if (useLeftUnits) {\n      tokens.reverse();\n    } // Find unique moment token types in the template in order of\n    // descending magnitude.\n\n\n    var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\")))); // Exit early if there are no moment token types.\n\n    if (!momentTypes.length) {\n      return pluck(tokens, \"text\").join(\"\");\n    } // Calculate values for each moment type in the template.\n    // For processing the settings, values are associated with moment types.\n    // Values will be assigned to tokens at the last step in order to\n    // assume nothing about frequency or order of tokens in the template.\n\n\n    momentTypes = map(momentTypes, function (momentType, index) {\n      // Is this the least-magnitude moment token found?\n      var isSmallest = index + 1 === momentTypes.length; // Is this the greatest-magnitude moment token found?\n\n      var isLargest = !index; // Get the raw value in the current units.\n\n      var rawValue;\n\n      if (momentType === \"years\" || momentType === \"months\") {\n        rawValue = remainderMonths.as(momentType);\n      } else {\n        rawValue = remainder.as(momentType);\n      }\n\n      var wholeValue = Math.floor(rawValue);\n      var decimalValue = rawValue - wholeValue;\n      var token = find(tokens, function (token) {\n        return momentType === token.type;\n      });\n\n      if (isLargest && maxValue && rawValue > maxValue) {\n        isMaxValue = true;\n      }\n\n      if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n        isMinValue = true;\n      } // Note the length of the largest-magnitude moment token:\n      // if it is greater than one and forceLength is not set,\n      // then default forceLength to `true`.\n      //\n      // Rationale is this: If the template is \"h:mm:ss\" and the\n      // moment value is 5 minutes, the user-friendly output is\n      // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n      // even though it has length of two if the template is \"h:mm:ss\";\n      //\n      // If the minutes output should always include the leading zero\n      // even when the hour is trimmed then set `{ forceLength: true }`\n      // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n      // clearly wanted everything padded so we should output \"05:00\";\n      //\n      // If the user wants the full padded output, they can use\n      // template \"hh:mm:ss\" and set `{ trim: false }` to output\n      // \"00:05:00\".\n\n\n      if (isLargest && forceLength === null && token.length > 1) {\n        forceLength = true;\n      } // Update remainder.\n\n\n      remainder.subtract(wholeValue, momentType);\n      remainderMonths.subtract(wholeValue, momentType);\n      return {\n        rawValue: rawValue,\n        wholeValue: wholeValue,\n        // Decimal value is only retained for the least-magnitude\n        // moment type in the format template.\n        decimalValue: isSmallest ? decimalValue : 0,\n        isSmallest: isSmallest,\n        isLargest: isLargest,\n        type: momentType,\n        // Tokens can appear multiple times in a template string,\n        // but all instances must share the same length.\n        tokenLength: token.length\n      };\n    });\n    var truncMethod = trunc ? Math.floor : Math.round;\n\n    var truncate = function truncate(value, places) {\n      var factor = Math.pow(10, places);\n      return truncMethod(value * factor) / factor;\n    };\n\n    var foundFirst = false;\n    var bubbled = false;\n\n    var formatValue = function formatValue(momentType, index) {\n      var formatOptions = {\n        useGrouping: useGrouping,\n        groupingSeparator: groupingSeparator,\n        decimalSeparator: decimalSeparator,\n        grouping: grouping,\n        useToLocaleString: useToLocaleString\n      };\n\n      if (useSignificantDigits) {\n        if (significantDigits <= 0) {\n          momentType.rawValue = 0;\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        } else {\n          formatOptions.maximumSignificantDigits = significantDigits;\n          momentType.significantDigits = significantDigits;\n        }\n      }\n\n      if (isMaxValue && !bubbled) {\n        if (momentType.isLargest) {\n          momentType.wholeValue = maxValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (isMinValue && !bubbled) {\n        if (momentType.isSmallest) {\n          momentType.wholeValue = minValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n\n      if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n        // Apply precision to least significant token value.\n        if (precision < 0) {\n          momentType.value = truncate(momentType.wholeValue, precision);\n        } else if (precision === 0) {\n          momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n        } else {\n          // precision > 0\n          if (useSignificantDigits) {\n            if (trunc) {\n              momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n            } else {\n              momentType.value = momentType.rawValue;\n            }\n\n            if (momentType.wholeValue) {\n              significantDigits -= momentType.wholeValue.toString().length;\n            }\n          } else {\n            formatOptions.fractionDigits = precision;\n\n            if (trunc) {\n              momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n            } else {\n              momentType.value = momentType.wholeValue + momentType.decimalValue;\n            }\n          }\n        }\n      } else {\n        if (useSignificantDigits && momentType.wholeValue) {\n          // Outer Math.round required here to handle floating point errors.\n          momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n          significantDigits -= momentType.wholeValue.toString().length;\n        } else {\n          momentType.value = momentType.wholeValue;\n        }\n      }\n\n      if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n        formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n        if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n          delete formatOptions.maximumSignificantDigits;\n        }\n      }\n\n      if (!foundFirst && (momentType.value > 0 || trim === \"\"\n      /* trim: false */\n      || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        foundFirst = true;\n      }\n\n      momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n      formatOptions.useGrouping = false;\n      formatOptions.decimalSeparator = \".\";\n      momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n      if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n        momentType.formattedValueMS = formatNumber(momentType.value, {\n          minimumIntegerDigits: 3,\n          useGrouping: false\n        }, \"en\").slice(0, 2);\n      }\n\n      return momentType;\n    }; // Calculate formatted values.\n\n\n    momentTypes = map(momentTypes, formatValue);\n    momentTypes = compact(momentTypes); // Bubble rounded values.\n\n    if (momentTypes.length > 1) {\n      var findType = function findType(type) {\n        return find(momentTypes, function (momentType) {\n          return momentType.type === type;\n        });\n      };\n\n      var bubbleTypes = function bubbleTypes(bubble) {\n        var bubbleMomentType = findType(bubble.type);\n\n        if (!bubbleMomentType) {\n          return;\n        }\n\n        each(bubble.targets, function (target) {\n          var targetMomentType = findType(target.type);\n\n          if (!targetMomentType) {\n            return;\n          }\n\n          if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n            bubbleMomentType.rawValue = 0;\n            bubbleMomentType.wholeValue = 0;\n            bubbleMomentType.decimalValue = 0;\n            targetMomentType.rawValue += 1;\n            targetMomentType.wholeValue += 1;\n            targetMomentType.decimalValue = 0;\n            targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n            bubbled = true;\n          }\n        });\n      };\n\n      each(bubbles, bubbleTypes);\n    } // Recalculate formatted values.\n\n\n    if (bubbled) {\n      foundFirst = false;\n      significantDigits = significantDigitsCache;\n      momentTypes = map(momentTypes, formatValue);\n      momentTypes = compact(momentTypes);\n    }\n\n    if (outputTypes && !(isMaxValue && !settings.trim)) {\n      momentTypes = map(momentTypes, function (momentType) {\n        if (find(outputTypes, function (outputType) {\n          return momentType.type === outputType;\n        })) {\n          return momentType;\n        }\n\n        return null;\n      });\n      momentTypes = compact(momentTypes);\n    } else {\n      // Trim Large.\n      if (trimLarge) {\n        momentTypes = rest(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - the smallest moment type\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n        });\n      } // Largest.\n\n\n      if (largest && momentTypes.length) {\n        momentTypes = momentTypes.slice(0, largest);\n      } // Trim Small.\n\n\n      if (trimSmall && momentTypes.length > 1) {\n        momentTypes = initial(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          // - the largest momentType\n          return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n        });\n      } // Trim Mid.\n\n\n      if (trimMid) {\n        momentTypes = map(momentTypes, function (momentType, index) {\n          if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n            return null;\n          }\n\n          return momentType;\n        });\n        momentTypes = compact(momentTypes);\n      } // Trim Final.\n\n\n      if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n        momentTypes = [];\n      }\n    }\n\n    if (returnMomentTypes) {\n      return momentTypes;\n    } // Localize and pluralize unit labels.\n\n\n    each(tokens, function (token) {\n      var key = momentTokens[token.type];\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!key || !momentType) {\n        return;\n      }\n\n      var values = momentType.formattedValueEn.split(\".\");\n      values[0] = parseInt(values[0], 10);\n\n      if (values[1]) {\n        values[1] = parseFloat(\"0.\" + values[1], 10);\n      } else {\n        values[1] = null;\n      }\n\n      var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n      var labels = durationGetLabels(key, localeData);\n      var autoLocalized = false;\n      var pluralizedLabels = {}; // Auto-Localized unit labels.\n\n      each(localeData._durationLabelTypes, function (labelType) {\n        var label = find(labels, function (label) {\n          return label.type === labelType.type && label.key === pluralKey;\n        });\n\n        if (label) {\n          pluralizedLabels[label.type] = label.label;\n\n          if (stringIncludes(token.text, labelType.string)) {\n            token.text = token.text.replace(labelType.string, label.label);\n            autoLocalized = true;\n          }\n        }\n      }); // Auto-pluralized unit labels.\n\n      if (usePlural && !autoLocalized) {\n        labels.sort(durationLabelCompare);\n        each(labels, function (label) {\n          if (pluralizedLabels[label.type] === label.label) {\n            if (stringIncludes(token.text, label.label)) {\n              // Stop checking this token if its label is already\n              // correctly pluralized.\n              return false;\n            } // Skip this label if it is correct, but not present in\n            // the token's text.\n\n\n            return;\n          }\n\n          if (stringIncludes(token.text, label.label)) {\n            // Replece this token's label and stop checking.\n            token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n            return false;\n          }\n        });\n      }\n    }); // Build ouptut.\n\n    tokens = map(tokens, function (token) {\n      if (!token.type) {\n        return token.text;\n      }\n\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n\n      if (!momentType) {\n        return \"\";\n      }\n\n      var out = \"\";\n\n      if (useLeftUnits) {\n        out += token.text;\n      }\n\n      if (isNegative && isMaxValue || !isNegative && isMinValue) {\n        out += \"< \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && isMinValue || !isNegative && isMaxValue) {\n        out += \"> \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n\n      if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        out += \"-\";\n        isNegative = false;\n      }\n\n      if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n        out += momentType.formattedValueMS;\n      } else {\n        out += momentType.formattedValue;\n      }\n\n      if (!useLeftUnits) {\n        out += token.text;\n      }\n\n      return out;\n    }); // Trim leading and trailing comma, space, colon, and dot.\n\n    return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n  } // defaultFormatTemplate\n\n\n  function defaultFormatTemplate() {\n    var dur = this.duration;\n\n    var findType = function findType(type) {\n      return dur._data[type];\n    };\n\n    var firstType = find(this.types, findType);\n    var lastType = findLast(this.types, findType); // Default template strings for each duration dimension type.\n\n    switch (firstType) {\n      case \"milliseconds\":\n        return \"S __\";\n\n      case \"seconds\": // Fallthrough.\n\n      case \"minutes\":\n        return \"*_MS_\";\n\n      case \"hours\":\n        return \"_HMS_\";\n\n      case \"days\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"d __\";\n        }\n\n      case \"weeks\":\n        if (firstType === lastType) {\n          return \"w __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"w __, d __, h __\";\n\n      case \"months\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"M __\";\n        }\n\n      case \"years\":\n        if (firstType === lastType) {\n          return \"y __\";\n        }\n\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, M __, d __\";\n\n      default:\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n\n        return \"y __, d __, h __, m __, s __\";\n    }\n  } // init\n\n\n  function init(context) {\n    if (!context) {\n      throw \"Moment Duration Format init cannot find moment instance.\";\n    }\n\n    context.duration.format = durationsFormat;\n    context.duration.fn.format = durationFormat;\n    context.duration.fn.format.defaults = {\n      // Many options are defaulted to `null` to distinguish between\n      // 'not set' and 'set to `false`'\n      // trim\n      // Can be a string, a delimited list of strings, an array of strings,\n      // or a boolean.\n      // \"large\" - will trim largest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"small\" - will trim smallest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"both\" - will execute \"large\" trim then \"small\" trim.\n      // \"mid\" - will trim any zero-value tokens that are not the first or\n      // last tokens. Usually used in conjunction with \"large\" or \"both\".\n      // e.g. \"large mid\" or \"both mid\".\n      // \"final\" - will trim the final token if it is zero-value. Use this\n      // option with \"large\" or \"both\" to output an empty string when\n      // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n      // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n      // \"left\" - maps to \"large\" to support plugin's version 1 API.\n      // \"right\" - maps to \"large\" to support plugin's version 1 API.\n      // `false` - template tokens are not trimmed.\n      // `true` - treated as \"large\".\n      // `null` - treated as \"large\".\n      trim: null,\n      // stopTrim\n      // A moment token string, a delimited set of moment token strings,\n      // or an array of moment token strings. Trimming will stop when a token\n      // listed in this option is reached. A \"*\" character in the format\n      // template string will also mark a moment token as stopTrim.\n      // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n      stopTrim: null,\n      // largest\n      // Set to a positive integer to output only the \"n\" largest-magnitude\n      // moment tokens that have a value. All lesser-magnitude moment tokens\n      // will be ignored. This option takes effect even if `trim` is set\n      // to `false`.\n      largest: null,\n      // maxValue\n      // Use `maxValue` to render generalized output for large duration values,\n      // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n      /// applied to the greatest-magnitude moment token in the format template.\n      maxValue: null,\n      // minValue\n      // Use `minValue` to render generalized output for small duration values,\n      // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n      // applied to the least-magnitude moment token in the format template.\n      minValue: null,\n      // precision\n      // If a positive integer, number of decimal fraction digits to render.\n      // If a negative integer, number of integer place digits to truncate to 0.\n      // If `useSignificantDigits` is set to `true` and `precision` is a positive\n      // integer, sets the maximum number of significant digits used in the\n      // formatted output.\n      precision: 0,\n      // trunc\n      // Default behavior rounds final token value. Set to `true` to\n      // truncate final token value, which was the default behavior in\n      // version 1 of this plugin.\n      trunc: false,\n      // forceLength\n      // Force first moment token with a value to render at full length\n      // even when template is trimmed and first moment token has length of 1.\n      forceLength: null,\n      // userLocale\n      // Formatted numerical output is rendered using `toLocaleString`\n      // and the locale of the user's environment. Set this option to render\n      // numerical output using a different locale. Unit names are rendered\n      // and detected using the locale set in moment.js, which can be different\n      // from the locale of user's environment.\n      userLocale: null,\n      // usePlural\n      // Will automatically singularize or pluralize unit names when they\n      // appear in the text associated with each moment token. Standard and\n      // short unit labels are singularized and pluralized, based on locale.\n      // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n      // of \"1 seconds\" or \"1 secs\". The default pluralization function\n      // renders a plural label for a value with decimal precision.\n      // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n      // Label types and pluralization function are configurable in the\n      // localeData extensions.\n      usePlural: true,\n      // useLeftUnits\n      // The text to the right of each moment token in a format string\n      // is treated as that token's units for the purposes of trimming,\n      // singularizing, and auto-localizing.\n      // e.g. \"h [hours], m [minutes], s [seconds]\".\n      // To properly singularize or localize a format string such as\n      // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n      // to the left of each moment token, set useLeftUnits to `true`.\n      // This plugin is not tested in the context of rtl text.\n      useLeftUnits: false,\n      // useGrouping\n      // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useGrouping: true,\n      // useSignificantDigits\n      // Treat the `precision` option as the maximum significant digits\n      // to be rendered. Precision must be a positive integer. Significant\n      // digits extend across unit types,\n      // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n      // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useSignificantDigits: false,\n      // template\n      // The template string used to format the duration. May be a function\n      // or a string. Template functions are executed with the `this` binding\n      // of the settings object so that template strings may be dynamically\n      // generated based on the duration object (accessible via `this.duration`)\n      // or any of the other settings. Leading and trailing space, comma,\n      // period, and colon characters are trimmed from the resulting string.\n      template: defaultFormatTemplate,\n      // useToLocaleString\n      // Set this option to `false` to ignore the `toLocaleString` feature\n      // test and force the use of the `formatNumber` fallback function\n      // included in this plugin.\n      useToLocaleString: true,\n      // formatNumber fallback options.\n      // When `toLocaleString` is detected and passes the feature test, the\n      // following options will have no effect: `toLocaleString` will be used\n      // for formatting and the grouping separator, decimal separator, and\n      // integer digit grouping will be determined by the user locale.\n      // groupingSeparator\n      // The integer digit grouping separator used when using the fallback\n      // formatNumber function.\n      groupingSeparator: \",\",\n      // decimalSeparator\n      // The decimal separator used when using the fallback formatNumber\n      // function.\n      decimalSeparator: \".\",\n      // grouping\n      // The integer digit grouping used when using the fallback formatNumber\n      // function. Must be an array. The default value of `[3]` gives the\n      // standard 3-digit thousand/million/billion digit groupings for the\n      // \"en\" locale. Setting this option to `[3, 2]` would generate the\n      // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n      grouping: [3]\n    };\n    context.updateLocale('en', engLocale);\n  } // Run feature tests for `Number#toLocaleString`.\n\n\n  toLocaleStringWorks = featureTestToLocaleString();\n  toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding(); // Initialize duration format on the global moment instance.\n\n  init(moment); // Return the init function so that duration format can be\n  // initialized on other moment instances.\n\n  return init;\n});","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/moment-duration-format/lib/moment-duration-format.js"],"names":["root","factory","define","amd","exports","module","require","e","momentDurationFormatSetup","moment","toLocaleStringWorks","toLocaleStringRoundingWorks","types","split","bubbles","type","targets","value","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","stringRound","digits","digitsArray","reverse","i","carry","parseInt","toString","push","join","formatNumber","number","options","userLocale","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","decimalSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","roundingOptions","extend","parseFloat","toLocaleString","numberString","toPrecision","toFixed","integerString","fractionString","exponentString","temp","integerLength","fractionLength","digitCount","replace","exponent","Math","abs","formattedString","group","shift","durationLabelCompare","a","b","label","durationGetLabels","token","localeData","labels","each","keys","localeDataKey","labelType","toLowerCase","labelKey","key","durationPluralKey","integerValue","decimalValue","engLocale","durationLabelsStandard","S","SS","s","ss","m","mm","h","hh","d","dd","w","ww","M","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","string","isArray","array","Object","prototype","call","isObject","obj","findLast","callback","index","find","max","match","item","map","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","initial","reversed","hasOwnProperty","any","flatten","child","concat","toLocaleStringSupportsLocales","name","featureTestToLocaleStringRounding","featureTestToLocaleString","passed","durationsFormat","args","arguments","settings","durations","arg","template","precision","returnMomentTypes","formattedDurations","dur","format","outputTypes","largest","durationFormat","defaults","asMilliseconds","asMonths","isValid","isNegative","remainder","duration","remainderMonths","momentTokens","years","months","weeks","days","hours","minutes","seconds","milliseconds","tokenDefs","escape","general","typeMap","test","tokenizer","RegExp","source","apply","stopTrim","_durationTimeTemplates","locale","useLeftUnits","usePlural","forceLength","trunc","useSignificantDigits","significantDigits","significantDigitsCache","minValue","isMinValue","maxValue","isMaxValue","trim","trimIncludes","rLarge","rSmall","rBoth","rMid","rAll","rFinal","trimLarge","trimSmall","trimMid","trimFinal","rawTokens","text","currentToken","tokens","momentTypes","momentType","isSmallest","isLargest","rawValue","as","wholeValue","floor","subtract","tokenLength","truncMethod","round","truncate","places","factor","pow","foundFirst","bubbled","formatValue","formatOptions","formattedValue","formattedValueEn","formattedValueMS","findType","bubbleTypes","bubble","bubbleMomentType","target","targetMomentType","outputType","values","pluralKey","autoLocalized","pluralizedLabels","_durationLabelTypes","sort","out","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","updateLocale"],"mappings":"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","sourcesContent":["/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `toLocaleString` for formatting.\n    // `userLocale` option is passed through to `toLocaleString`.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (!toLocaleStringRoundingWorks) {\n                var roundingOptions = extend({}, options);\n                roundingOptions.useGrouping = false;\n                roundingOptions.decimalSeparator = \".\";\n                number = parseFloat(formatNumber(number, roundingOptions), 10);\n            }\n\n            return number.toLocaleString(userLocale, localeStringOptions);\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestToLocaleStringRounding() {\n        return (3.55).toLocaleString(\"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestToLocaleString() {\n        var passed = true;\n\n        // Test locale.\n        passed = passed && toLocaleStringSupportsLocales();\n        if (!passed) { return false; }\n\n        // Test minimumIntegerDigits.\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (typeof this.isValid === \"function\" && this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    toLocaleStringWorks = featureTestToLocaleString();\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n"]},"metadata":{},"sourceType":"script"}